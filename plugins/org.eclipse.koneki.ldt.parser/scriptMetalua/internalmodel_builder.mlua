-{ extension 'match' }
local internalmodel = require 'internalmodel'
local externalapi = require 'externalapi'
local Q = require 'metalua.treequery'
require 'metalua.walk'
require 'metalua.walk.bindings'


local M = {}

local function pdown (node,parent)
     print (tostring(node.tag) .. " down")
end
  
local function pup (node, parent)
   print (tostring(node.tag).. " up")     
end


-- define if a node is a block
local function supportedblock(node)
  return node.tag =="Function"
end

-- create a block from node
local function createblock(block)
     local b =   internalmodel._block()
     match block with
      | `Function{param, body} ->
         b.sourcerange.min = block.lineinfo.first.offset
         b.sourcerange.max = block.lineinfo.last.offset
      | _ ->
     end
     return b
end

-- define if a node is a supported expression
local function supportedexpr(node)
  return node.tag =="Index" or node.tag =="Id" or node.tag=="Call"
end


local idToBlock = {}
local handledIdentifier = {}
-- create an expr from node
local function createexpr(expr,_block)
    match expr with
    | `Id { name } ->
         -- create identifier
         local _identifier = internalmodel._identifier()
         -- we store the block which hold this node 
         -- to be able to define   
         idToBlock[expr]= _block
         handledIdentifier[expr]= _identifier
         return _identifier                                   
    | `Index { innerexpr, `String{f} } ->
         -- create index
         local e = createexpr(innerexpr,_block)
         if e then return internalmodel._index(e,f) end
    | `Call{innerexpr, ...} ->
         -- create call 
         local e = createexpr(innerexpr,_block)
         if e then return internalmodel._call(e) end
    | `Invoke{innerexpr,`String{f},...} ->
         -- create invoke
         -- create call 
         local e = createexpr(innerexpr,block)
         if e then return internalmodel._invoke(f,e) end
    | _ ->
   end
   
   return nil
end


local handledexpr = {}

-- create block and expression node
local function createTreeStructure(ast) 
  local internalcontent = internalmodel._internalcontent()
  local b= internalmodel._block()
  internalcontent.content = b
  local blocks = {b}
  b.sourcerange.min = ast.lineinfo.first.offset
  b.sourcerange.max = ast.lineinfo.last.offset
  
  local function down (node,parent)
    if supportedblock(node) then
       -- create the block
       local b = createblock(node)
       -- add it to parent block
       table.insert(blocks[#blocks].content, b) 
       -- enqueue the last block to know the "current" block
       table.insert(blocks,b)
    elseif supportedexpr(node) then
       -- create expr
       local e = createexpr(node,blocks[#blocks])
       -- add it to parent block
       if e then
          table.insert(blocks[#blocks].content, e)
          -- store this node as supported expr
          handledexpr[node] = e
       end  
    end
  end
  
  local function up (node, parent)
    if supportedblock(node) then
       -- dequeue the last block to know the "current" block
       table.remove(blocks,#blocks)
    end     
  end
  
  Q(ast):not_under(supportedexpr):foreach(down,up)    
  return internalcontent
end
 
local function getType(node, itemname)
   match node with
   | `Local {ids, inits} ->
      for i,id in ipairs(ids) do
         local idname = id[1]
         if itemname == idname then
            -- create type
            local type = nil
            
            -- return data
            return id, type 
         end
      end
   | _ ->
   end
end
 

local function createLocalVars(internalcontent,ast)
  
  local locals, globals = bindings( ast )

  -- create locals var
  for node, namesAndOccurrences in pairs(locals) do
      for name, occurences in pairs(namesAndOccurrences) do
            -- create item
            local _item = externalapi._item(name)
            
            -- get type and id 
            local id, type = getType(node, name)
            if (id) then
              -- table.print (id)
                     
   --            -- add declaration
   --            table.insert(item.occurences, handledIdentifier[id])
   
   --            -- add occurences
   --            for _,occurence in ipairs(occurences)
   --              local _identifier = handledIdentifier[occurence]
   --              if _identifier then
   --                 table.insert(_item.occurences, _identifier)
   --                 _identifier.definition = _item 
   --              end 
   --            end
   
               -- add item to block
               local _block = idToBlock[id]
               table.insert(_block.localvars,{item=_item,scope = {min=0,max=0}})
            end  
      end
   end
  
  
  -- create globals var
--  for name, occurrences in pairs( globals ) do
--     -- TODO
--     -- local item = externalapi._item()
--     -- foreach occurence blabla
--     --table.insert(internalcontent.unknownglobalvars,item)    
--  end
end
 
function M.createInternalContent (ast)
   -- create block and expression node
   local internalcontent = createTreeStructure(ast)
   
   -- create Local vars (Items)
   createLocalVars(internalcontent,ast)
   
   return internalcontent
end

return M 